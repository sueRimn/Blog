# ES6
## 声明变量
### let
* 声明常量
* 块级作用域，不受外部影响
	* 允许在块级作用域内声明函数
		* 函数声明会提升到全局作用域或函数作用域头部，类似`var`
		* 函数声明会提升到所在块级作用域的头部
* 不存在变量提升-声明后才可以使用
* 暂时性死区-声明后才可以使用
* 不允许在相同作用域内重复声明同一个变量
* 不能在函数内部重新声明参数
### const
* 声明常量，常量不可被修改（常量使用全大写字母标识，单词间用下划线连接）
	* 如果声明引用类型，则不能改变其内存地址
* 声明时必须赋值
* 块级作用域
* 不存在常量提升
* 存在暂时性死区-声明后才可以使用
* 不允许在相同作用域内重复声明同一个常量

**是否属于顶层对象的属性**

* 属于
	* `var/function`声明的全局变量
* 不属于
	* `let/const/class`声明的全局变量
 ### 箭头函数
* 使用箭头`(=>)`定义函数
* 有参数时，使用圆括号`（）`代表参数部分
* 代码块>一条语句时，要使用大括号{}括起来
* 返回一个对象时，对象必须使用大括号{}括起来
* 注意事项
	* 1.函数体内的`this`对象指定义时所在的对象，而不是使用时所在的对象。即本身没有自己的`this`，引用的是上下文的`this`，和外层执行上下文的this绑定了
		不必写`let that = this`;
	* 2.没有`arguments`
	* 3.没有`prototype`属性，不能用作构造函数（不能使用`new`命令）
### 解构赋值
#### 用法
直接使用对象的某个属性，而不需要通过属性访问的形式使用
#### 分类
##### 1.数组的解构赋值
* 模式匹配：原理其实是消耗数组的迭代器，把生成对象的`value`属性的值赋值给对应的变量
* 按次序排列，变量的取值由它的位置决定
* 一个用途是交换变量，避免以前要声明一个临时变量值存储值
##### 2.对象的解构赋值
* 直接使用对象的某个属性，而不需要通过属性访问的形式使用
* 没有次序，变量必须与属性同名才可以取到正确的值
##### 3.字符串的解构赋值
* 类似数组的对象
##### 4.数值和布尔值的解构赋值
* 等号右边为数值和布尔值，会先转为对象
##### 5.函数参数的解构赋值
#### 允许使用默认值
#### 只要等号右边的值不是对象或数组，就先将其转为对象
#### undefined和null无法进行解构赋值
### iterator迭代器
数据集合
* 数组（`Array`）
* 对象（`Object`）
* `Map`
* `Set`
### 剩余/扩展预算符
#### 扩展运算符
```JavaScript
let arr = [1,2,3,4,5]===let arr = [...[4,5]]
```
* 只要含有`iterator`接口的数据解构都可以使用扩展运算符
* 使用3个点（...），后面跟着一个数组，数组是存放元素集合的一个容器，剩余/扩展运算符可以将这个容器拆开

**应用**

* 赋值数组:数组是复合的数据类型，赋值数组只是复制了指向顶层数据结构的指针，而不是克隆一个全新的数组  `const a2 = [...a1]`
* 合并数组：`[...arr1,...arr2,...arr3]`
* 与解构赋值结合：扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个
#### 剩余运算符
* 最重要的一个特点就是替代了以前的`arguments`
* 箭头函数没有`arguments`，必须使用剩余运算符才能访问参数集合
#### 区别
* 剩余运算符会收集这些集合，放到右边的数组中
* 扩展运算符是将右边的数组拆分成元素的集合
### for...of循环
* 允许遍历一个含有`iterator`接口的数据结构并且返回各项的值
* 遍历获取对象的键值
* 只遍历当前对象不会遍历整个原型链
* 对于数组的遍历，只返回数组的下标对应的属性值
### promise对象
> 实现异步操作
#### 基本用法
**构造函数，通过new关键字创建Promise实例**

* 接受一个函数作为参数，该函数有两个参数
  * `resolved`：从“未完成”变为“成功”（即从 `pending` 变为` resolved`），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
	* `rejected`：将`Promise`对象的状态从“未完成”变为“失败”（即从 `pending` 变为 `rejected`），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
      
**实例生成后，可以用then分别指定resolved状态和rejected状态的两个回调函数**

`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行
#### Promise对象的特点
* 对象的状态不受外界影响
* 对象代表一个异步操作，有三种状态
	* `pending`（进行中）
	* `fulfield`（已成功）
	* `rejected`（已失败）
* 只有异步操作的结果可以觉得当前是哪一种状态，任何其他操作都无法改变这个状态
* 状态改变的可能
	* 1.从`pending`变为`fulfield`
	* 2.从`pending`变为`rejected`
### ES6 模块
`ES6 Module`默认目前还没有被浏览器支持，需要使用`babel`。可以在`script`标签中使用`tpye="module"`在同域的情况下可以解决（非同域情况会被同源策略拦截，webstorm会开启一个同域的服务器没有这个问题，vscode貌似不行）

**特点**

* 使用`import`关键字导入模块，`export`关键字导出模块
* 是静止的，在编译阶段运行，和`var`以及`function`一样具有提升效果
* 自动采用严格模式（顶层`this`返回`undefined`）
* 支持使用`export`{<变量>}导出具名的接口，或者`export default`导出匿名的接口
  * 这两者的区别是:`export `{<变量>}导出的是一个变量的引用，`export default`导出的是一个值
### 函数默认值
* 允许在函数的参数中设置默认值
	* 如果使用了函数默认参数,在函数的参数的区域(括号里面),它会作为一个单独的作用域,并且拥有`let/const`方法的一些特性,比如暂时性死区,块级作用域,没有变量提升等,而这个作用域在函数内部代码执行前
* 函数默认值配合解构赋值
### Proxy（拦截器）
> 在目标对象前架设一个拦截器，他人访问对象必须先经过这层拦截器
