## 面向对象编程(OPP)
> 具有灵活、代码可复用、高度模块化等特点，易维护和开发
## 实例对象与new命令
### 1.对象
- 对象是单个实物的抽象
- 对象是一个容器，封装了属性（prototype）和方法（method)
  * 属性是对象的状态
  * 方法是对象的行为
### 2.构造函数
JavaScript使用构造函数作为对象的模板，描述实例对象的基本结构

**定义**
* 专门用来生成实例对象的函数
* 第一个字母通常大写

**特点**
* 函数体内部使用了this关键字，代表所要生成的对象实例
* 生成对象的时候，必须使用`new`命令
### 3.new命令
**基本用法**
* new命令的作用就是执行构造函数，返回一个实例对象
* 根据需要，构造函数也可以接受参数
**原理**
* 使用new命令时，它后面的函数依次执行下面的步骤
	* 1.创建一个空对象，作为将要返回的对象实例
	* 2.将这个空对象的原型，指向构造函数的`prototype`属性
	* 3.将这个空对象赋值给函数内部的`this`关键字
	* 4.开始执行构造函数内部的代码
* 构造函数内部，this指的是一个新生成的空对象
**new.target**

	如果当前函数是new命令调用，`new.target`指向当前函数，否则为`undefined`
### 4.this关键字
**涵义**
* 可以用在构造函数中，表示实例对象
* 它总是返回一个对象
* `this`就是属性或方法“当前”所在的对象
* 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即`this`的指向是可变的

**使用场合**
* 全局环境：`this`指的就是顶层对象`window`
* 构造函数：`this`指的是实例对象
* 对象的方法：`this`指的就是方法运行时所在的对象

**使用注意点**
* 避免多层this
	* 解决方法：使用一个固定`this`的值，然后内层函数调用这个变量 `var that = this`
* 避免数组处理方法中的`this`	 
	* 数组的`map`和`forEach`方法，运行提供一个函数作为参数。这个函数内部不应该使用`this`
	* 解决方法
		* 1.`var that = this`
		* 2.将`this`当作`forEach`方法的第二个参数，固定它的运行环境
* 避免回调函数中的`this`

**绑定this的方法**
* Function.prototype.call()
	* 可以指定函数内部`this`的指向（即函数执行时所在的作用域），然后在所指定的作用域内，调用该函数
	* `call`方法的参数，应该是一个对象。如果参数为空、`null`、`undefined`,则默认传入全局对象
	* `call`方法可以接受多个参数。第一个参数就是`this`所要指向的那个对象，后面的参数则是函数调用时所需的参数
* Function.prototype.apply()
	* 它与`call`的唯一区别就是，它接收一个数组作为函数执行时的参数
	* `apply`方法的第一个参数也是this所要指向的那个对象，如果设为`null`或`undefined`，则等同于指定全局对象
	* 第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数
	* 原函数的参数，在`call`方法中必须一个个添加，但是在`apply`方法中，必须以数组形式添加
	* 应用
		* 1.找出数组的最大元素：结合使用`apply`方法和`Math.max`方法
		* 2.将数组的空元素变为`undefined`
		* 3.转换类似数组的对象：利用数组对象的`slice`方法，可以将一个类似数组的对象（比如`arguments`对象）转为真正的数组
		* 4.绑定回调函数的对象
* Function.prototype.bind()
	* 用于将函数体内的`this`绑定到某个对象，然后返回一个新函数
	* 使用注意点
		* 1.每一次返回一个新函数
		* 2.结合回调函数使用
		* 3.结合`call`方法使用
### 5.对象的继承
**原型对象**

构造函数的缺点是同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。解决方法：使用`prototype`

`prototype`属性的作用就是：`JavaScript` 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享原型对象的作用就是定义所有实例对象共享的属性和方法

**原型链**

由于原型对象也是对象，所以它也有自己的原型，对象到原型，再到原型的原型……
* 所有对象都继承了`Object.prototype`的属性
* `Object.prototype`的原型是`null`,原型链的尽头就是`null`
* `Object.getPrototypeOf`方法返回参数对象的原型

**constructor属性**

`prototype`对象有一个`constructor`属性，默认指向`prototype`对象所在的构造函数，可以被所有实例对象继承
