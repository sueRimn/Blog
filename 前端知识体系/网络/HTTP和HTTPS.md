###　HTTP和HTTPS是什么

**HTTP**

基于`TCP/IP`通信协议来传递数据的超文本传输协议,是客户端和服务端请求和应答的标准(TCP)，用于从WWW服务器传输文本到本地浏览器的传输协议,使浏览器更加高效,减少网络传输

**HTTPS**

以安全为目标的`HTTP`通道,在`HTTP`下加入`SSL`层,是由`HTTP`和`SSL`协议构建的可进行坚弥传输和身份认证的协议,主要作用就是建立一个信息安全通道确保数组传输和网站的真实性.

### HTTP和HTTPS的区别

* `HTTPS`协议需要ca证书,费用较高
* `HTTP`是超文本传输协议,明文传输,`HTTPS`是具有安全性的`SSL`加密传输
* 链接方式和端口都不同,`HTTP`的端口是80,`HTTPS`的端口是443
* `HTTP`链接简单、无状态，`HTTPS`是由`HTTP`和`SSL`构建的加密传输、身份认证的网络协议，安全性更高

### HTTPS协议工作原理

- 客户端使用https URL 方问服务器，要求服务器建立ssl链接
- 服务器收到客户端请求后，将网站证书传给客户端
- 客户端和服务器协商建立加密等级
- 客户端通过协商后的加密登记建立会话密钥，然后通过网站的公钥来加密会话密钥传送给网站
- 服务器通过自己的私钥解密出会话密钥
- 服务器通过会话密钥来加密与客户端之间的通信

### https的优缺点

#### （1）优点

- 使用可认证的服务器和证书，确保数据传输到正确的客户端和服务器
- 由http和SSL构建的可进行加密、身份认证的网络协议，比http安全
- 虽然不是绝对安全，但是大幅增加了中间人攻击的成本

#### （2）缺点

- 握手阶段费时间，增加页面加载时间
- 缓存不如http高效，增加了数据开销
- SSL证书费用成本
- SSL证书需要绑定IP

### HTTP2.0特性

HTTP2.0是HTTP1.0的更新

* 提升访问速度
* 运行多路复用：允许同时通过单一的HTTP/2连接发送多重请求-响应信息
* 二进制分帧：传输信息分割为更小的信息或者帧，并对他们进行二进制编码
* 首部压缩
* 服务器端推送

### HTTP支持的方法

GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT

**Get与POST的区别**

* `get`参数通过`url`传递，`post`放在`request body`中
* `get`请求在`url`中传递的参数是有长度限制的，而`post`没有
* `get`比`post`更不安全，因为参数直接暴露在`url`中，所以不能用来传递敏感信息
* `get`请求只能进行`url`编码，而`post`支持多种编码方式
* `get`请求参数会被完整保留在浏览历史记录里，而`post`中的参数不会被保留
* `get`产生一个`TCP`数据包；`post`两个`TCP`数据包
* 缓存方面的区别：
  * `get`请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存
  * `post`做的一般是修改和删除的工作，必须与数据库交互，所以不能使用缓存

### HTTP的请求报文是什么样的？

请求行+请求头+空行+请求内容体

### HTTP的响应报文是什么样的？

响应行+响应头+空行+响应内容体

### HTTP请求方式

* `head`：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头
* `options`：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等

### HTTP常用请求头

* `Accept`：可接收的响应内容类型
  * `text/html`：浏览器可以接受服务器回发的类型为 text/html
  * `*/*`：浏览器可以处理所有类型（默认）
* `Accept-Charset`：可接受字符集
* `Accept-Encoding`：可接受的响应内容编码方式
  * `gzip`
  * `deflate`
* `Accept-Language`：可接受的响应内容语言列表
* `Accept-Datetime`：可接受的按照时间来表示的响应内容版本
* `Cache-Control`：用来指定当前的请求/回复中的，是否使用缓存机制
  * `private`：响应作为私有缓存，不能用户间共享（默认）
  * `public`：缓存可在用户间共享
  * must-revalidate`：响应在特定条件下重用
  * `no-cache`：响应不会缓存，实时向服务器请求资源
  * `max-age=10`：设置缓存最大有效时间，单位秒
  * `no-store`：任何条件下响应都不会缓存，并且不会写入客户端磁盘
* `Connection`：客户端（浏览器）想要优先使用的连接类型
  * `keep-alive`：当一个网页打开完成后，客户端和服务器之间用于传输`HTTP`数据的`TCP`连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接
  * `close`：代表一个`Request`完成后，客户端和服务器之间用于传输`HTTP`数据的`TCP`连接会关闭， 当客户端再次发送`Request`，需要重新建立`TCP`连接
* `Content-Length`：请求体长度
* `Cookie`：以便服务器辨别身份
* `Range`：用于断点续传
* `Refresh`：刷新重定向
* `Date`：服务端发送资源时的服务器时间
* `Content-Type`：请求体类型
* `Origin`：发起一个针对跨域资源共享的请求
* `HOST`：服务器的域名以及服务器所监听的端口号
* `Referer`：浏览器所访问的前一个页面
* `Last-modified`： 请求对象的最后修改日期
* `Transfer-Encoding`：通知客户端服务器发送的资源是分块发送

### TCP三次握手和四次挥手

* `TCP`是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

* `TCP`可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在`TCP`头部。

* `TCP`提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接，采用4次挥手来关闭一个连接。

客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

客户端和服务端都需要坐到各自可收发数据，所以需要三次握手

- 第一次握手：两端都处于关闭状态，客户端发送一个SYN段，并指明客户端的初始序列号
- 第二次握手：服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传
- 第三次握手：为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值

四次挥手：

* 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K， 同时还包含一个ACK表示确认对方最近一次发过来的数据。 
*  服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作
*  服务端发起自己的FIN段，ACK=K+1, Seq=L 
*  客户端确认。ACK=L+1

### TCP和UDP的区别

- 发送数据，TCP是面向连接的，UDP是无连接的
- TCP是面向连接的可靠性传输，而UDP是不可靠的
- TCP是面向字节流，UDP面向报文
- TCP一对一，UDP支持一对一，一对多
- TCP首部２０字节，UDP８字节

## TCP和IP的网络模型

TCP/IP模型是一系列网络协议的总称，这些协议的目的是使得计算机之间可以进行信息交换

TCP/IP模型四层架构从下到上分别是：

* 链路层：建立电路连接
* 网络层：负责分配地址和传输二进制数据，IP
* 传输层：传送文本数据，TCP
* 应用层：传送各种最终形态的数据，HTTP

### 状态码

HTTP 响应状态代码指示请求是否已成功完成。

响应信息分为五类：

* 信息响应：100-199，服务器收到请求，需要请求者继续执行操作
* 成功响应：200-299，操作被成功接收并处理
* 重定向：300-399，需要进一步操作完成请求
* 客户端错误：400-499，请求包含语法错误或无法完成请求
* 服务器错误：500-599，服务器在处理请求的过程中发生错误

常见的如下：

#### (1)信息响应

- 100：内容可行，客户端继续请求，如若完成则忽略
- 101：服务器已经理解了客户端的请求,并将通过`Upgrade 消息头`通知客户端采用不同的协议来完成这个请求
- 102：服务端已收到正在处理，无响应可用
- 103：允许用户代理在服务器准备响应的时候预加载资源

#### (2)成功响应

- **200**: 请求成功，成功的含义取决于HTTP方法：
  - `GET`：资源已被提取并在消息正文中传输
  - `HEAD`：实际标头位于消息正文中
  - `POST`：描述动作结果的资源在消息体内传输
  - `TRACE`：消息正文包含服务器收到的请求消息
  - 
- 202：请求已接收，未响应
- 203：服务器已成功处理请求，返回内容
- **204**：请求成功处理，没有实体的主体返回
- 205：服务器已成功处理请求，没有返回内容
- 206：服务器已成功处理部分GET请求

#### （3）重定向

* 300：多重选择进行重定向
* **301**：永久重定向，请求资源已被移到新URL
* **302**：临时重定向，所请求的页面已经临时转移至新的url
* **303**：所请求的页面可在别的url下被找到，应使用GET定向获取请求资源
* **304**：未按预期修改文档
* 305：客户请求的文档应该通过Location头所指明的代理服务器提取
* 306：客户请求的文档应该通过Location头所指明的代理服务器提取
* **307**：临时重定向，被请求的页面已经临时移至新的url

#### （4）客户端错误

* 400：请求无效（请求提交的数据出错或者类型错误）
* 401：当前请求需用户验证
* 403：服务器已收到请求但是拒绝执行
* 404：服务器无法找到被请求的页面

#### （5）服务器错误

* 500： 服务器执行请求的时候出错
* 503：服务器超负载或停机维护，无法处理请求

### Fetch发送两次的原因

用`fetch`的`post`请求的时候，第一次发送的是一个`Options`请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。

### 什么是RESTFUL

用`URL`定位资源，用`HTTP`描述操作

## OSI七层模型

从上到下：

* 应用层：文件传输，常用协议HTTP，SNMP、FTP
* 表示层：数据格式化，代码转换，数据加密
* 会话层：建立、关闭会话
* 传输层：提供端到端接口，TCP、UDP
* 网络层：为数据包选择路由，IP、ICMP
* 数据链路层：传输有地址的帧
* 物理层：二进制的数据形式在物理媒体上传输数据